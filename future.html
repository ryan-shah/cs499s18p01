<html>
<head>
	<title>Future Enhancements</title>
</head>

<body>
	<h1>Future Enhancements</h1>
	<p>There are a number of features and improvements that we have not been able to implement over the course of the semester.  None of them are so important as to render the software unusable for the customers, but they should be noted nonetheless.  Included for each are considerations that a future developer or group of developers should take into account if they decide to act on what possible future enhancements we have below.</p>
	<p>To begin, the software does not have the ability to run and monitor clusters.  These are programs that call other programs related to each other.  While it is not implemented, the process of adding the implementation has been made relatively simple.  There is an empty function called ‘track_cluster()’ where such an implementation can be imported.  Other things will need to be added as well, including adding a column to the programs table of the database that contains a boolean that will determine whether or not the program in question is a cluster and adding a checkbox to ‘addProgramModal’ for the user to notify the website whether or not the program in question is a cluster.</p>
	<p>Another helpful inclusion that was not implemented is a real-time search on the website for both scripts and schedules.  This was not a problem experienced during development, but as more schedules and scripts are added, it will become cumbersome for a user to have to scroll a great deal to find what they want.  In terms of implementing this, the only sources we found read through tables, so the names of the scripts and the names of the schedules will need to be placed into two tables so that they could be searched in real-time.</p>
	<p>Moving on, there is not a complete implementation of editing the database through the website.  This problem can be circumvented by simply deleting and adding a fixed version of the entry, but the user experience would be strengthened significantly by the addition of editing.  That said, including this implementation is non-trivial for a number of reasons.  One of the biggest reasons is that pulling current data from the table and properly presenting that information in the form, especially in parts of the form that use &lt;select&gt; or &lt;select multiple&gt;, will be non-trivial, to say the least.</p>
	<p>Speaking of forms, there is currently no form validation in the modals.  While we trust that our customers will understand the software well enough so as to not create too many issues, input will sometimes be invalid, and they will not be caught by the website as-is.  This will cause issues in the future if not addressed.  We would like to provide one example to illustrate our point.  As of now, it is possible to have two programs accidentally be made dependant on each other within the same runlist, creating a dependency loop.  In this case, programs independent of the dependency loop in question would run first, but the dependency loop would never run, preventing the runlist from completing, subsequently preventing data from being sent to the database and website.  Implementing form validation would be both non-trivial and tedious due to both the vast number of ways a user could conceivably cause the software to fail and the amount that needs to be considered to make each element of the forms fool-proof.</p>
	<p>Another avenue of improvement lies in the lack of security built into our software.  While our customers have a strong firewall, it would be an added bonus to implement security for the software.  We currently have a basic implementation of a login page, but registration is currently delegated to editing the MySQL database directly.  Because of the amount of work that would be needed to implement everything involved and the security that already exists with their firewall, our customers may simply see this as a non-issue.</p>
	<p>The last issue is with general optimization, but there is one problem in this vein that deserves special attention.  Whenever there is an update to the database, ‘update_Json()’ is called for the user who caused the change in the database.  This function deletes and recreates the user’s copy of spydr.json, calling the database multiple times all the while.  While this isn’t terribly slow when spydr.json is small, it isn’t unreasonable to assume the database will be changed frequently, and the performance hit will only increases as more will be added to the database.  Optimizing this functionality would be difficult for at least two reasons.  To start, there would need to be a systematic way parameters would be sent to ‘update_Json()’ so that it could parse out which changes were made and update spydr.json accordingly.  The other reason is more indirect in nature.  During development of this project, each team member had their own version of spydr.json that would get overwritten when changes were pulled from git.  While including spydr.json into its associated .gitignore would prevent spydr.json from being overwritten, that only solves part of the problem.  While the database is a single instance that changes for everyone, each developer has their version of spydr.json, which only updates if they change the database. Because of this, further development that would include optimizing ‘update_Json()’ would require creating a route that calls the inefficient version of ‘update_Json()’ that would update their spydr.json in case there are changes to the database that they did not make.  This would ensure that the latest version of spydr.json is being used when spydr.cpp is called during development.</p>
</body>

</html>
